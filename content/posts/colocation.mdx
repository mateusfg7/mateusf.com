---
title: 'Co-localiza√ßao'
date: '2023-06-05'
description: 'Princ√≠pio da co-localiza√ß√£o na organiza√ß√£o de bases de c√≥digo, de Kent C. Dodds.'
category: 'Article'
tags: 'patterns, architecture, code, Clean Code, javascript, react, html, tradu√ß√£o'
author: 'mateusfg7'
status: 'published'
---

# Introdu√ß√£o

> Esta √© uma tradu√ß√£o da postagem original [Colocation](https://kentcdodds.com/blog/colocation) de [Kent C. Dodds](https://kentcdodds.com/).

Todos n√≥s queremos ter bases de c√≥digo f√°ceis de manter, ent√£o come√ßamos com a melhor das inten√ß√µes para tornar nossa base de c√≥digo (ou nosso canto da base de c√≥digo) sustent√°vel e f√°cil de entender. Com o tempo, √† medida que uma base de c√≥digo cresce, pode se tornar cada vez mais dif√≠cil gerenciar depend√™ncias (JS, CSS, imagens, etc.). √Ä medida que os projetos crescem, uma quantidade crescente de sua base de c√≥digo se torna "conhecimento tribal" (conhecimento do qual apenas voc√™ ou alguns outros t√™m acesso) e esse tipo de conhecimento contribui para a "d√≠vida t√©cnica" (seja esse termo preciso [ou n√£o](https://twitter.com/ryanflorence/status/747983065738153985)).

Eu gosto de manter minhas bases de c√≥digo gerenci√°veis n√£o apenas para mim (aquele que o escreveu), mas tamb√©m para meus colegas de equipe, futuros mantenedores e para mim mesmo em 6 meses. Acho que todos podemos concordar que esse √© um grande ideal pelo qual devemos nos esfor√ßar em nossas bases de c√≥digo. Existem muitas ferramentas e t√©cnicas diferentes √† nossa disposi√ß√£o para realizar isso.

# Vamos falar sobre coment√°rios de c√≥digo

N√£o quero discutir se deve comentar seu c√≥digo (voc√™ deveria) e sobre o que seus coment√°rios devem ser (voc√™ explica por que est√° fazendo algo inesperado nos coment√°rios para que as pessoas que v√™m depois possam entender as decis√µes que foram tomadas que resultaram em o c√≥digo inesperado ou estranho). (Ok, talvez eu queira falar um pouco sobre isso). Em vez disso, quero me concentrar em onde esses coment√°rios de c√≥digo s√£o colocados. Geralmente "co-localizamos" esses coment√°rios com o c√≥digo que eles est√£o explicando, colocando-os o mais pr√≥ximo poss√≠vel do c√≥digo relevante.

Considere por um minuto, se fiz√©ssemos isso de forma diferente. E se colocarmos esses coment√°rios em um arquivo totalmente separado. Um enorme arquivo `DOCUMENTATION.md` ou talvez at√© mesmo um diret√≥rio `docs/` que mapeia de volta para o nosso diret√≥rio `src/`. Parece divertido para voc√™? Sim, para mim tamb√©m n√£o. Haveria alguns problemas s√©rios que encontrar√≠amos ao n√£o co-localizar nossos coment√°rios com o c√≥digo que est√° explicando.

- **Manutenibilidade**: eles ficariam fora de sincronia ou desatualizados mais rapidamente (do que j√° est√£o). Mover√≠amos ou excluir√≠amos um arquivo `src/` sem atualizar o arquivo `docs/` correspondente.
- **Aplicabilidade**: as pessoas que olham para o c√≥digo em `src/` podem perder um coment√°rio importante em `docs/` ou n√£o comentar seu pr√≥prio c√≥digo porque n√£o percebem que existe um arquivo `docs/` para o arquivo `src/` que est√£o editando.
- **Facilidade de uso**: a troca de contexto de um local para outro tamb√©m seria um desafio com esse tipo de configura√ß√£o. Ter que lidar com v√°rios locais para arquivos pode tornar dif√≠cil garantir que voc√™ tenha tudo o que precisa para manter um componente.

Definitivamente, poder√≠amos criar uma conven√ß√£o para esse tipo de estilo de coment√°rio de c√≥digo, mas por que ir√≠amos querer? N√£o √© mais simples manter os coment√°rios co-localizados com o c√≥digo que est√£o explicando?

# E da√≠?

Agora, voc√™ provavelmente est√° pensando consigo mesmo: "Sim, claro, √© por isso que ningu√©m faz essa coisa de `docs/` e todo mundo apenas co-localiza seus coment√°rios com o c√≥digo. Isso √© √≥bvio. Qual √© o seu ponto?" Meu ponto √© que os benef√≠cios da co-localiza√ß√£o est√£o em toda parte.

# HTML/Visualiza√ß√£o

Tome HTML, por exemplo. Todos os benef√≠cios de co-localizar nossos coment√°rios tamb√©m se traduzem em nossos modelos. Antes de estruturas modernas como o React, voc√™ teria sua l√≥gica de visualiza√ß√£o e seus modelos de visualiza√ß√£o em diret√≥rios totalmente separados. Isso √© v√≠tima dos mesmos problemas descritos acima. Hoje em dia √© muito mais comum colocar essas coisas **exatamente no mesmo arquivo** com React e Vue, por exemplo. Com Angular, se n√£o estiver no mesmo arquivo, o arquivo de modelo est√° pelo menos pr√≥ximo ao arquivo JS ao qual est√° associado.

# CSS

Outro conceito ao qual isso se aplica bem √© o CSS. N√£o vou discutir com voc√™ sobre os m√©ritos do CSS-in-JS (√© fant√°stico), mas os benef√≠cios s√£o de outro mundo. [Saiba mais aqui](https://medium.com/seek-blog/a-unified-styling-language-d0c208de2660).

# Testes

Esse conceito de co-localiza√ß√£o de arquivos tamb√©m se aplica muito bem a testes de unidade. Qu√£o comum √© encontrar um projeto com um diret√≥rio `src/` e um diret√≥rio `test/` preenchido com testes de unidade que tentam espelhar o diret√≥rio `src/`? Todas as armadilhas descritas acima tamb√©m se aplicam aqui. Eu provavelmente n√£o iria t√£o longe a ponto de colocar os testes de unidade exatamente no mesmo arquivo, mas tamb√©m n√£o descarto totalmente isso como uma ideia interessante (a implementa√ß√£o √© deixada como um exerc√≠cio para o leitor).

Para ajudar a permitir uma base de c√≥digo mais sustent√°vel, devemos co-localizar nossos arquivos de teste com o arquivo ou grupo de arquivos que est√£o testando. Isso garante que, quando novas pessoas (ou eu mesmo em 6 meses) chegarem ao c√≥digo, elas possam ver imediatamente que o m√≥dulo foi testado e usar esses testes como refer√™ncia para aprender sobre o m√≥dulo. Quando eles fazem altera√ß√µes, ele os lembra de atualizar (adicionar/remover/modificar) os testes para contabilizar suas altera√ß√µes.

# Estado

O estado do aplicativo/componente apresenta os mesmos benef√≠cios. Quanto mais desconectado/indireto for seu estado da IU que o est√° usando, mais dif√≠cil ser√° mant√™-lo. A localiza√ß√£o do estado tem ainda mais benef√≠cios do que a capacidade de manuten√ß√£o, mas tamb√©m melhora o desempenho do seu aplicativo. Uma altera√ß√£o de estado em um canto da √°rvore de componentes do aplicativo renderizar√° muito menos componentes do que uma altera√ß√£o de estado no topo da √°rvore. Localize seu estado.

# Arquivos utilit√°rios "reutiliz√°veis"

Isso tamb√©m se aplica a arquivos e fun√ß√µes "utilit√°rias". Imagine que voc√™ est√° escrevendo um componente e v√™ um bom peda√ßo de c√≥digo que pode ser extra√≠do em sua pr√≥pria fun√ß√£o. Voc√™ extrai e pensa: "Ah... aposto que muita gente poderia usar isso." Ent√£o voc√™ o retira e coloca no diret√≥rio `utils/` do seu aplicativo e segue em frente com sua vida.

Posteriormente, seu componente √© exclu√≠do, mas o utilit√°rio que voc√™ escreveu est√° fora de vista, fora da mente e permanece (junto com seus testes) porque a pessoa que o excluiu presumiu que era mais usado. Ao longo dos anos, os engenheiros trabalharam duro para garantir que a fun√ß√£o e seus testes continuem a funcionar corretamente, mesmo sem perceber que n√£o s√£o mais necess√°rios. Esfor√ßo desperdi√ßado e carga cognitiva.

Se, em vez disso, voc√™ tivesse deixado essa fun√ß√£o diretamente no arquivo que a utilizou, a hist√≥ria seria completamente diferente. N√£o estou dizendo para n√£o se incomodar com o teste de unidade de fun√ß√µes utilit√°rias complexas (por favor, fa√ßa), mas mant√™-las mais perto de onde s√£o necess√°rias ajuda a evitar problemas.

<Warn>
E, pelo amor de Deus, [APAGUE ESTA REGRA ESLINT](https://github.com/yannickcr/eslint-plugin-react/blob/e6b4c33a1db4cc94c3e9223b09fb92b1dbddc00d/docs/rules/no-multi-comp.md) e todas as regras semelhantes.
</Warn>

# O princ√≠pio

**O conceito de co-localiza√ßao pode ser resumido a este princ√≠pio fundamental:**

<Tip>
Coloque o c√≥digo o mais pr√≥ximo poss√≠vel de onde √© relevante
</Tip>

Voc√™ tamb√©m pode dizer: "As coisas que mudam juntas devem ser localizadas o mais pr√≥ximo poss√≠vel." ([Dan Abramov](https://twitter.com/dan_abramov) disse algo assim para mim uma vez).

# C√≥digo aberto facilita

Al√©m de evitar os problemas discutidos anteriormente, h√° outros benef√≠cios em estruturar seus projetos dessa maneira. Pegar um componente e transform√°-lo em um projeto de c√≥digo aberto geralmente √© t√£o simples quanto copiar/colar a pasta para outro projeto e public√°-lo no npm. Em seguida, basta instal√°-lo em seu projeto e atualizar suas instru√ß√µes de `require`/`import` e pronto.

# Exce√ß√µes

Claro que h√° um bom argumento para a documenta√ß√£o que abrange todo ou parte de um sistema e como as coisas se integram. E onde voc√™ colocaria a integra√ß√£o ou os testes de ponta a ponta que abrangem os componentes? _Voc√™ pode pensar que essas s√£o exce√ß√µes_, mas na verdade elas podem se encaixar perfeitamente no princ√≠pio mencionado acima

Se eu tiver uma parte do meu aplicativo associada √† autentica√ß√£o do usu√°rio e quiser documentar esse fluxo, posso colocar um arquivo `README.md` na pasta que cont√©m todos os m√≥dulos associados √† autentica√ß√£o do usu√°rio. Se eu precisar escrever testes de integra√ß√£o para esse fluxo, posso colocar o arquivo desses testes na mesma pasta.

Para testes de ponta a ponta, geralmente faz mais sentido ir na raiz do projeto. Eles v√£o al√©m do pr√≥prio projeto e em outras partes do sistema, ent√£o faz sentido para mim que estejam em um diret√≥rio separado. Eles realmente n√£o mapeiam para os arquivos `src/`. Na verdade, os testes E2E realmente n√£o se importam com a forma como o `src/` est√° organizado. A refatora√ß√£o e a movimenta√ß√£o de arquivos no diret√≥rio `src/` n√£o devem exigir a altera√ß√£o dos testes E2E.

# Conclus√£o

Nosso objetivo aqui √© construir um software que seja o mais simples poss√≠vel de manter. Os mesmos benef√≠cios de **manutenibilidade**, **aplicabilidade** e **facilidade** de uso que obtemos com a colocaliza√ß√£o de nossos coment√°rios, tamb√©m obtemos com a colocaliza√ß√£o de outras coisas. Se voc√™ nunca experimentou, recomendo que experimente.

P.S. Se voc√™ est√° preocupado em violar a "separa√ß√£o de preocupa√ß√µes", recomendo que verifique [esta palestra](https://youtu.be/x7cQ3mrcKaY) de [Pete Hunt](https://twitter.com/floydophone) e reavalie o que isso significa üòÄ.

P.P.S. Tamb√©m devo observar que isso se aplica muito bem a imagens e a qualquer outro recurso tamb√©m. E quando voc√™ usa uma ferramenta como o [webpack](https://webpack.js.org/), co-localizar esses recursos tamb√©m √© muito f√°cil. Honestamente, esta √© uma das principais propostas de valor do webpack IMO.
